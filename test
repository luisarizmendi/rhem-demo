
# Red Hat Edge Manager product demo


This is a repo that helps reproducing a red hat edge manager (rhem) product demo, a product based on the flightctl (https://github.com/flightctl/flightctl) upstream open source project. this is not an specific use case demo, but a demo of the product capabilities), including how to setup a quick environment, the steps to perform and notes about what to mention on each step.

What people will learn in this demo:
- How easy is to onboard edge devices at scale without specialized knowledge
- Teh advantages of using image-based inmmutable operating systems as the bootc RHEL images
- How you can manage applications and configurations on edge devices using RHEM in a descriptive way
- How RHEM simplifies the observability and access to the edge devices at scale even in envirnoments with network restrictios
- (add more)


Total time needed for demo: xxxx


Note: This is an early version of this demo, and the product is under heavely development, so I will try to improve it over time to show new functionalities.



## About this repo

This repo contains the following directories:


.github: where the GitHub actions workflow is defined. 

"apps": application definition using podman-compose files and related containerfile to embed that compose file into a container image so it can be hosted in a container image registry


"devices": Bootc device image definitions

"configs": Files used to configure the devices in runtime usgin RHEM instead on in image build time

"fleets": RHEM fleet definitions used during the demo.

"docs": directory with additional documentation, including a copy in pdf of an example slide deck that can be used to walkthrough the demo just in case you don't have access to the Google Docs version here (https://docs.google.com/presentation/d/1iNxrpVPw-vnr56oIOzliasBiDuSkQH9p9CD0RHEP04Y/edit?usp=sharing).


The GitHub actions workflow detects changes in apps and devices directories and perform container image builds based on the files located in those changed directories. IT will create images for x86 and arm and an associated conatiner image manifest to create a single multi-arch image. The name of the image will be the directory name plus a prefix (device-demo-x for bootc image under "devices" directory and app-demo-x for the applications). It will add some tags, including the version (eg. v2) by adding +1 to the last version already creaTED.


## Preparing the demo


what you need: your laptop, virtualization software, red hat subscription, flightctl cli, ...



steps to prepare your repo:

- clone this repo

- Configure your repo to run gtihub actions. This includes:

###  Enable Required Workflow Permissions

To allow the workflow to read repository contents and push packages:

1. Go to **Repository Settings** → **Actions** → **General**.
2. Scroll to **Workflow permissions**.
3. Select:
   - ✅ **Read repository contents and packages permissions**
4. Click **Save**.

### Include your Red Hat user and password

To allow pulling the base RHEL bootc image from the Red Hat registry you need your credentials:

1. Go to **Repository Settings** → **Secrets and variables** → **Actions**.
2. Add the following **Repository secrets**:
   - `RH_USERNAME`: Your Red Hat registry username
   - `RH_PASSWORD`: Your Red Hat registry password




steps to prepare the demo:

- Deploy RHEM. For a quick demo you might use the (not supported) standalone deployment since it requires less infrastructure and you can use the latest and greatest release (eg. using "kind" and "helm" as mentioned in the repo https://github.com/flightctl/flightctl/blob/main/docs/user/getting-started.md). 

- obtain config.yaml from rhem

- create both versions (version 1 and 2 ) of the images (kvm and kiosk), you will see in the Containerfiles and the compose.yaml the proposed changes for the version 2. Copy the config.yaml in devices/kiosk and devices/kvm. Push the changes into your repo, the github actions workflow will create the images and push it into the GitHub registry for you.

- Create the installable artifacts for the v1 of the images

- Create the APP podman-compose images but making any small change in any file in apps/postgres/ (add space, comment, ...). The github actions workflow will create the app image and push it into the registry for you.

- Test demo steps below before running the final demo. 

Note: If onboarding does not work check that the device vm can reach out to the RHEM address.







## Opening

It's important to mention the challange that we are addressing. If you are using slide deck you will probably cover that there, if not just mention the challanges managing edge devices, includig large scale, lack of specialized people onsite, resource contraints hardware, networking contratraints, (add more) 

Introduce your demo environment, for example if you used kind explain what is kind, show RHEM running on top of it and explain how you deploy it there.

It is important that if you used the non-suported deployment (standalone) explain that RHEM is distributed as part of ansible automation platform or advance cluster management, not as standalone product at least today, but we did it to show the latest bits and also to be able to use less infrastructure (and being able to use just a laptop).



## Demo steps

it's time to run the demo. You can run all steps at once or run them while you are going through each different setion on the slides


### Building the device

+ Description:

In this step we are going to create a bootc image that has embedded the rhem agent on it, including the required certificates and api endpoint that it needs to use to onboard the device.

+ Time required: ~ 5 minutes (+ build running on background during other steps)

+ Points to mention:

- Explain the bootc image generation and how you can do it with generic container tools, like podman, buildah, pipelines, ...In this demo we are building using github actions but you can automate the bootc image build in multiple ways. you can find some ideas here: https://github.com/luisarizmendi/bootc-build-scenarios

- This is one approach, a different oen woudl be to create a generic image with the agent but without the certificates and endpoint information, and do it while onboarding the device using any other method based on the infrastructure, for example cloud-init if you are deploying on a cloud environment. that makes the image generic and possible to be used with different rhem but also makes it dependant on the infrastructure tools 


- Along with the bootc image we also need to create an instalable artifact that will be used to deploy the image in an empty device (hardware or virtual machine). In our case we already created ISOs that we will use


- In this demo we will be using two different images, the KVM image is just a device that can run VMs on it, the second one is the "Kiosk" image, that can be used to deploy images and present them in GNOME kiosk mode on the device (explain what is kiosk mode).


- In order to save time, the images and the installable artifacts have been already created, what we will do is to launch a new image creation version to demo the image creation



+ Steps:

- Open a terminal in your laptop, and use flightctl to get the config.yaml

- Open one of the Containerfiles and show how that config.yaml file is embeded into the image, and how the rhem agent is installed. 

Note: you might explain that in the Containerfile we have the subscription and unsubscription of the image in order to be able to install packages, that's because for simplicity we are using an Ubuntu image in the github actions workflow. if you use a registered rhel to buidl your images you won't need to add that since the buidl will take the subscription from the host.

- Make a change in the Containerfile (eg. add tmux package)

- Push the change and open the "Actions" tab in your GitHub repo to show how the workflow started

- After some time (probably at the end of the next section) come back to show the workflow and show in the Git Hub repo "packages" section the new images generated.



+ Value statement:


- By using bootc we reusage of container tools and knowledge to create RHEL images. Easy to automate.

- Additional features possible because of using container image registries, for example rhel image signature, at rest security scans, etc

- Reduce infra required to distribute the image, since we can use the same image continer registry to distribute both the app images and the device operating system images





### Onboarding

+ Description: In this section we are going to see how to deploy and enroll new devices into RHEM using a zero-touch provisioning


+ Time required: ~ 7 minutes (2:30 min wait during onboarding)

+ Points to mention:

- Explain how you created the instalable artifact adn what are the kinds of artifacts taht you can create with bootc-image-builder (ISO, QCOW2, AMI, VMDK, ...)

- Explain that we are simulating that we are using a USB with the ISO in a physical device in this demo instead of directly using a qcow2 althouhg we are using VMs. Also explain that you can use other more automated ways such as pxe booting the ISO from network connected centralized server.


+ Steps:

- Create a VM with 1.5 GB memory and 2 vCPUs

- Boot from ISO using the "KVM" device image

- Wait until the terminal shows a QR. time required will vary but will be around 2:30 minutes. Explain that the QR open the RHEM UI interface.

- Open RHEM and show the enrollement request, including all the details about the device

- Accept the request. The checks will turn green after some time (more or less 2 minutes)



+ Value statement:

- This zero touch provisioning approach helps simplifying the onboarding process, no need to experts onsite. Advantages of zero-touch-provisioning when you don't have peopke with tech knowledge onsite and why that's useful in edge use cases (cost and time)

- Decoupling the image from the installable artifact has benefits sice you can create different artifacts depending on where you plan to install, for example you can use an ISO when installing on baremetal and a qcow2 if you plan to use VMs on KVM

- The communication between the device and RHEM is secure and it always use a pull mode management, opening the connections from teh edge site to the core site. that simplifies the network setup since you don't ahve to deal with NAT and aopening ports in the firewall.



### Managing device configurations

+ Description:

We are going to see how RHEM can manage device configuration during the runtime.


+ Time required: ~ 5 minutes


+ Points to mention:

- It is always better to include required configurations during the image creation instead at running time since it assures better consistency

- Changes in configuration files in the Git repo are not translated directly into the devices (so if you push a change in the configuration file in the repo the device wont' get it even if its enrolled and managed by RHEM), you can update changes by updating the device configuration in RHEM.


+ Steps:

- Show mot of the day file in the "configs/function/generic" directory

- Go to RHEM, open the device and edit it. Add the configuration file "/etc/motd" using either the in-line entry or directly the git repo option

- Apply changes and wait until the configuration drift is detected (it could take 2:30 min more or less)

- After the change is detected, it will take some time to apply it. Once done you can login (VM terminal or SSH) into the device and see if you can see the Mot of the Day message right after loging

- In this example we are going to add a message when you login into the devices, thansk to the mot of the day configuration file that you have in linux systems.

+ Value statement:

-  When this is not feasible or desirable to include the configuration during the image creation, you can use RHEM to dynamically configure at runtime, Examples: Configuration that is deployment- or site-specific (e.g. site-specific network credential), Secrets that are not secure to distribute via the image,... 

- Being able to host the configuration files in a git repo brings some of the GitOps methodology and descriptive configuration benefits, such as better change tracking, change rollbacks, etc 



### Deploying and upgrading applications

+ Description:

We are going to see how to deploy and update containerized applications by using Docker Compose files embeded into container images hosted in an OCI registry. 


+ Time required: ~ 10 minutes (4 minutes wait for app deployment + 2 min wait app upgrade)


+ Points to mention:

- Explain how the conatiner images containing the compose files where created. they were created in advance to save time. Explain that those images are not the service conatiner image, but a scratch conatiner iamge containing just the compose file that describes and it is used to deploy the application.

- Explain that you can also use directly the compose file while defining the application in RHEM but using the OCI approach is better to improve consistency and simplify the application definition distribution.

- as it happens with the configs, if you can embed the applications in the bootc image is better for consistency, but it also means that you bind the app lifecycle to the bootc image lifecycle times.

- We are going to deploy a postgres database and the pgadmin management tool.

- We will deploy version pgadmin 9.5 and then update it to 9.6 in a further step.


+ Steps:

- Show compose.yaml and Containerfile used to create the app container image.

- Go to RHEM UI, open the device and then configure the application, including the OCI image (v1) and the following environment variables (values are examples):

POSTGRES_USER: postgres
POSTGRES_PW: pgredhat
POSTGRES_DB: postgres
PGADMIN_MAIL: pgadmin@none.com
PGADMIN_PW: pgredhat

- Accept changes and wait until drift is detected and device is updated with the application. Time to deploy the application will depend on the VM resources and network since it will pull the application container images from internet. If you wan to show something while waiting you can run `watch 'podman image list ; echo ""; podman ps' along with the journal to see how it pulls the iamge and runs the conatiners

- Once the application is deployed you can go to the devices ips on port 5050 and you will get the PGAdmin UI. Use the credentials that you configured in the variables to login

- (optional) Configure the postgres database that you  deployed in PGadmin

- Show that you are using version 9.5

- Change and push compose.yaml file in git to use version 9.6. 

- Show that the workflow starts building the new image. In order to save time explain that you already have a version 2 of the app image already prepared.

- Go to RHEM, edit the device and change the version of the application image to v2

- Wait to detec the change and upgrade

- Login again in PGadmin and show the version used, it should be 9.6


+ Value statement:

- If APPs need to be added, updated, or deleted without reboot or on a faster cadence than the OS then you can use RHEM to manage your applications on the edge devices

- Same benefits than with applications in regards to GitOps and descriptive configuration methodology.






### Device Operating System upgrade

+ Description:

We have seen how we can manage updated in applications on runtime, now we are going to see how to upgrade the device operating system, including the configuration and applications embeded on it.


+ Time required: ~ 7 minutes (5 minutes wait to apply upgrade)


+ Points to mention:

- Explains how RHEL image-based updates work and the rol of bootc on them

- Explain that we already created the v2 in advance to save time, the change is the add of the cockpit console in the device. Explain what is the cokcpit console.

- say that you can configure the used device image in the device configuration to force the usage or an specific version, or just let the image that the device is running. When you onboard the image is not setup, in this step we are going to set it up/force the device to our version 2. 

- Explain that today, with bootc, in order to apply the upgrade you need to restart the device, as you do when you update your mobile phone os.

+ Steps:

- Login in the  device (VM terminal or ssh) and check the image version that is runngin with the "bootc status" command

- Go to RHEM UI and edit the device

- Include the version 2 bootc image (the box should be empty since we didn't force any image version so far)

- wait until the change is detected, applied, and device rebot is completed. Time will dependon on the network and VM resources but it could be more or less 5 minutes in total

- Login in the device (VM terminal or ssh) and check the image version that is runngin with the "bootc status" command



+ Value statement:

- <add benefits of using bootc images for edge use cases and how RHEM helps>





### Device observability and troubleshooting

+ Description:

We are going to explore the built-in monitoring capabilities in RHEM and also how you can access the device's terminal 


+ Time required: ~ 3 minutes


+ Points to mention:

- We didn't configured any alarm sink (email, slack or webhooks) so we will see the alarm in the RHEM UI

- Alarm rising could take long depending on the RHEM configuration. We are going to use stress command to fill the device CPU. It could take minutes to show the alarm in RHEM UI since it needs to be sure that is not a spike and it is an actual issue, so we are going to run the stress command and move into the next section to save time.

- We will be accessing the device terminal from RHEM without opening ports in the edge location firewall because it uses the connection created from teh edge device 

- Alarms could be customized, for example to rise an alart when the device cpus goes beyond 55%. In this demo we use defaults.


+ Steps:

- We start demo the teminal access. Go to the RHEM UI, open the device and click on the Terminal tab. (It cuold take some time to open the termianl channel depending on VM resources and network, it could be something like 30 seconds or 1 minute.)

- Once login in the device, run stress command in background, for example to fill 2 vcpus "stress -c 2 &"

- Jump into the next section, eventually an alarm will be triggered in the UI and you will see it


+ Value statement:

- RHEM provides basic device monitoring built in, what <write about the benefit of this>

- You can connect to the device's console evne when firewall inbouund ports are not open, simplifying the network setup and security of your edge solution architecture. 



### Fleet management

+ Description:

So far we manage one single device, now we are going to see how we can mange a high number of devices as a fleet. 


+ Time required: 


+ Points to mention:

- <explain the fleet concept>

- You can use templates to change your fleet configuration based, for example on the lables of the device as we are going to do in this demo. The syntax for the fleet template placeholders matches that of Go templates (https://pkg.go.dev/text/template) formating.

- You can define fleets manually or you can use a gitops approach by creating a yaml file that describes your fleet. this is the approach in this demo.

- In our case, the tamplate in the fleet will apply different configurations in the device depending two labels that will determine the location of the device and the function/services that device will offer.

- The fleet to what a device is assigned is based on the labels that you configured. In our example devices with label "fleet=demo" will be part of this fleet.

- The configuration differences between different site labels are:

    "na": defined the 1.us.pool.ntp.org ntp server and the (fake) 10.10.1.5 container image registry
    "emea":  defined the 1.es.pool.ntp.org ntp server and the (fake) 192.168.1.5 container image registry


- The configuration differences between different "function" labels is that it will change the web page shown by the kiosk mode in the terminal.


+ Steps:

- Go to RHEM UI > repositories

- Create a new repository and resource pointing to the fleets/demo.yaml file in your git repo

- Apply and wait until it appears as synced

- Go to Fleets and you will see your fleet. Check the fleet configuration.


- Create a new VM with 2.5 GB memory and 2 vCPUs

- Boot from ISO using the "Kiosk" device image. (it is version 1 of that image)

- Wait until the terminal shows an app (Solvent Recovery)

- Go to RHEM UI and check the device enrollement request information. 

- This time assign fleet=demo labelsto the device while accepting the enrollment, along with the "site" (it could be ecual to "na" or "emea") and function (check the directory names under configs/function to know what are the available values for this label)

- After accepting it will take some time to apply changes, since it will change the configuration, apply a new bootc image and deploy the postgress application on it.

- Once done, you will see how the terminal kiosk will show the URL configured in the gnome-kiosk-script located in the configs/function/<label> directory.

- Login into the device. You can check the configurations based on the "site" label. Check files /etc/chrony.conf and /etc/containers/registries . You should see the configurations that you ahve in git depending on the site label that you configured 



+ Value statement:

- <again mentione value of manageing edge devices as fleet>

- The usage of templates makes possible to have flexible fleet definitions, reducing the number of those required. 

- <value of gitops and descriptive configuartion by usign fleet definitions in get>


## Closing

<resume the following >

RHEM provides a comprhensive fleet managemnet in a

simple way:

Intuitive edge operations
Bridge the IT skills gap at the edge with a
user-friendly environment designed for ease of
use and simplified management.

Flexible management options
Choose the deployment model that fits your strategy, with on-premises management offering comparable or superior value to cloud alternatives.


scalable way:

Policy-driven deployment
Implement a desired-state configuration model for both applications and infrastructure, enabling consistent and scalable deployments, maximizing operational efficiency.
Resilient pull-mode management
Use a robust agent-based architecture for scalable device management, maintaining connectivity and control even in challenging network conditions, without complex network configurations.


and build for edge:

Hardened device communications
Employ mutual Transport Layer Security (mTLS)
for robust and authenticated agent service communication. Establish a consistent security
posture even for re-connected devices through
rigorous identity verification.
Proactive device insights
Monitor critical device compute, memory and disk resources. Capture essential metrics and logs for effective issue remediation and operational awareness.
Lifecycle management
Provides secure onboarding, upgrades and decommissioning of applications and OS.


