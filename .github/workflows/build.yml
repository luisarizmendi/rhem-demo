name: Build bootc images with artifacts
on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Platforms to build (comma-separated)'
        required: true
        default: 'linux/amd64,linux/arm64'
      formats:
        description: 'Export formats (comma-separated)'
        required: true
        default: 'anaconda-iso,qcow2'
      device_types:
        description: 'Device types to build (comma-separated, leave empty for all changed)'
        required: false
        default: ''
  push:
    branches:
      - main

jobs:
  # Detect changed device types
  detect-changes:
    name: Detect changed device types
    runs-on: ubuntu-latest
    outputs:
      device-types: ${{ steps.changes.outputs.device-types }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed device types
        id: changes
        run: |
          set -euo pipefail
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.device_types }}" ]; then
            # Manual dispatch with specific device types
            DEVICE_TYPES="${{ github.event.inputs.device_types }}"
            echo "Manual dispatch with device types: $DEVICE_TYPES"
          else
            # Detect changes automatically
            if [ "${{ github.event_name }}" = "push" ]; then
              # For push events, compare with previous commit
              CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            else
              # For manual dispatch without specific types, build all available
              CHANGED_FILES=$(find devices -name "Containerfile" -o -name "containerfile" | head -20)
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # Extract unique device types from changed files in devices/ directory
            DEVICE_TYPES=$(echo "$CHANGED_FILES" | grep -E '^devices/[^/]+/' | sed 's|^devices/\([^/]*\)/.*|\1|' | sort -u | tr '\n' ',' | sed 's/,$//')
            
            if [ -z "$DEVICE_TYPES" ]; then
              echo "No device type changes detected"
              echo "has-changes=false" >> $GITHUB_OUTPUT
              echo "device-types=" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "Device types to build: $DEVICE_TYPES"
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "device-types=$DEVICE_TYPES" >> $GITHUB_OUTPUT

      - name: Validate device types
        run: |
          if [ "${{ steps.changes.outputs.has-changes }}" = "true" ]; then
            IFS=',' read -ra TYPES <<< "${{ steps.changes.outputs.device-types }}"
            for TYPE in "${TYPES[@]}"; do
              if [ ! -d "devices/$TYPE" ]; then
                echo "Error: devices/$TYPE directory does not exist"
                exit 1
              fi
              if [ ! -f "devices/$TYPE/Containerfile" ] && [ ! -f "devices/$TYPE/containerfile" ]; then
                echo "Error: No Containerfile found in devices/$TYPE"
                exit 1
              fi
            done
            echo "All device types validated successfully"
          fi

  # Setup job: Parse build parameters
  setup:
    name: Setup build parameters
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    outputs:
      platforms: ${{ steps.setup.outputs.platforms }}
      formats: ${{ steps.setup.outputs.formats }}
      matrix: ${{ steps.setup.outputs.matrix }}
      device-types: ${{ needs.detect-changes.outputs.device-types }}
    steps:
      - name: Setup build parameters
        id: setup
        run: |
          # Set platforms (from input or default)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            PLATFORMS="${{ github.event.inputs.platforms }}"
            FORMATS="${{ github.event.inputs.formats }}"
          else
            PLATFORMS="linux/amd64,linux/arm64"
            FORMATS="anaconda-iso,qcow2"
          fi
          
          echo "platforms=$PLATFORMS" >> $GITHUB_OUTPUT
          echo "formats=$FORMATS" >> $GITHUB_OUTPUT
          echo "Building for platforms: $PLATFORMS"
          echo "Building formats: $FORMATS"
          
          # Create matrix for build jobs (platform x device-type combinations)
          MATRIX='{"include":['
          FIRST=true
          
          IFS=',' read -ra PLATFORM_ARRAY <<< "$PLATFORMS"
          IFS=',' read -ra DEVICE_ARRAY <<< "${{ needs.detect-changes.outputs.device-types }}"
          
          for DEVICE_TYPE in "${DEVICE_ARRAY[@]}"; do
            for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
              ARCH="${PLATFORM#linux/}"
              
              if [ "$FIRST" = false ]; then
                MATRIX="${MATRIX},"
              fi
              FIRST=false
              
              if [ "$ARCH" = "arm64" ]; then
                RUNNER="ubuntu-24.04-arm"
              else
                RUNNER="ubuntu-latest"
              fi
              
              MATRIX="${MATRIX}{\"platform\":\"$PLATFORM\",\"arch\":\"$ARCH\",\"runner\":\"$RUNNER\",\"device-type\":\"$DEVICE_TYPE\"}"
            done
          done
          MATRIX="${MATRIX}]}"
          
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Matrix: $MATRIX"

  # Matrix job: Build the bootc images for each platform and device type
  build-image:
    name: Build BootC image
    needs: setup
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    outputs:
      image: ${{ steps.build.outputs.image }}
      tags: ${{ steps.build.outputs.tags }}
    env:
      IMAGE_NAME: device-example-${{ matrix.device-type }}
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Verify Containerfile exists
        run: |
          CONTAINERFILE_PATH=""
          if [ -f "devices/${{ matrix.device-type }}/Containerfile" ]; then
            CONTAINERFILE_PATH="devices/${{ matrix.device-type }}/Containerfile"
          elif [ -f "devices/${{ matrix.device-type }}/containerfile" ]; then
            CONTAINERFILE_PATH="devices/${{ matrix.device-type }}/containerfile"
          else
            echo "Error: No Containerfile found in devices/${{ matrix.device-type }}"
            exit 1
          fi
          echo "CONTAINERFILE_PATH=$CONTAINERFILE_PATH" >> $GITHUB_ENV
          echo "Using Containerfile: $CONTAINERFILE_PATH"

      - name: Log in to Red Hat Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: registry.redhat.io
          username: ${{ secrets.RH_USERNAME }}
          password: ${{ secrets.RH_PASSWORD }}

      - name: Prepare Buildah secrets for container subscription
        run: |
          echo "${{ secrets.RH_USERNAME }}" > secret-username
          echo "${{ secrets.RH_PASSWORD }}" > secret-password
          chmod 600 secret-username secret-password

      - name: Build platform-specific image with Buildah
        id: build
        uses: redhat-actions/buildah-build@v2
        with:
          image: ${{ env.IMAGE_NAME }}
          tags: |
            latest-${{ matrix.arch }}
            ${{ github.sha }}-${{ matrix.arch }}
          platforms: ${{ matrix.platform }}
          context: devices/${{ matrix.device-type }}
          containerfiles: |
            ${{ env.CONTAINERFILE_PATH }}
          extra-args: |
            --secret id=username,src=secret-username
            --secret id=password,src=secret-password
            --pull=always

      - name: Cleanup secret files
        run: rm -f secret-username secret-password

      - name: Setup empty Docker config
        run: |
          mkdir -p $HOME/.docker
          echo '{ "auths": {} }' > $HOME/.docker/config.json

      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push platform-specific image to GHCR
        id: push
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build.outputs.image }}
          tags: ${{ steps.build.outputs.tags }}
          registry: ${{ env.REGISTRY }}

  # Job: Create multi-platform manifest for each device type
  create-manifest:
    name: Create multi-platform manifests
    needs: [setup, build-image]
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    steps:
      - name: Log in to GitHub Container Registry
        uses: redhat-actions/podman-login@v1
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-platform manifests
        run: |
          set -euo pipefail
          
          IFS=',' read -ra DEVICE_ARRAY <<< "${{ needs.setup.outputs.device-types }}"
          
          for DEVICE_TYPE in "${DEVICE_ARRAY[@]}"; do
            IMAGE_NAME="device-example-${DEVICE_TYPE}"
            IMAGE_BASE="${{ env.REGISTRY }}/${IMAGE_NAME}"
            LATEST_MANIFEST="${IMAGE_BASE}:latest"
            SHA_MANIFEST="${IMAGE_BASE}:${{ github.sha }}"
            
            echo "Creating multi-platform manifests for device type: $DEVICE_TYPE"
            echo "Latest manifest: $LATEST_MANIFEST"
            echo "SHA manifest: $SHA_MANIFEST"
            
            # Remove existing manifests if they exist
            podman manifest rm "$LATEST_MANIFEST" 2>/dev/null || true
            podman manifest rm "$SHA_MANIFEST" 2>/dev/null || true
            
            # Create new manifests
            podman manifest create "$LATEST_MANIFEST"
            podman manifest create "$SHA_MANIFEST"
            
            # Add platform-specific images to manifests
            IFS=',' read -ra PLATFORM_ARRAY <<< "${{ needs.setup.outputs.platforms }}"
            for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
              ARCH="${PLATFORM#linux/}"
              PLATFORM_LATEST="${IMAGE_BASE}:latest-${ARCH}"
              PLATFORM_SHA="${IMAGE_BASE}:${{ github.sha }}-${ARCH}"
              
              echo "Processing platform: $PLATFORM (arch: $ARCH) for device: $DEVICE_TYPE"
              echo "  Adding $PLATFORM_LATEST to latest manifest"
              echo "  Adding $PLATFORM_SHA to SHA manifest"
              
              # Add to manifests with proper architecture specification
              podman manifest add --arch "$ARCH" --os "linux" "$LATEST_MANIFEST" "docker://$PLATFORM_LATEST"
              podman manifest add --arch "$ARCH" --os "linux" "$SHA_MANIFEST" "docker://$PLATFORM_SHA"
            done
            
            echo "Inspecting created manifests for $DEVICE_TYPE..."
            podman manifest inspect "$LATEST_MANIFEST"
            podman manifest inspect "$SHA_MANIFEST"
            
            echo "Pushing multi-platform manifests for $DEVICE_TYPE..."
            podman manifest push --all "$LATEST_MANIFEST" "docker://$LATEST_MANIFEST"
            podman manifest push --all "$SHA_MANIFEST" "docker://$SHA_MANIFEST"
            
            echo "Multi-platform manifests for $DEVICE_TYPE created and pushed successfully!"
          done

  ##
  # Need custom RHEL runner for subscriptions 
  #
  ##
  # # Matrix job: Build artifacts for each platform/format/device-type combination
  # build-artifacts:
  #   name: Build artifacts
  #   needs: [setup, build-image, create-manifest]
  #   strategy:
  #     fail-fast: false
  #     matrix: ${{ fromJson(needs.setup.outputs.matrix) }}
  #   runs-on: ${{ matrix.runner }}
  #   env:
  #     REGISTRY: ghcr.io/${{ github.repository_owner }}
  #     IMAGE_NAME: device-example-${{ matrix.device-type }}
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4

  #     - name: Parse platform
  #       id: platform
  #       run: |
  #         echo "arch=${{ matrix.arch }}" >> $GITHUB_OUTPUT
  #         echo "safe_arch=${{ matrix.arch }}" >> $GITHUB_OUTPUT

  #     - name: Set up QEMU (only for cross-platform builds if needed)
  #       if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'
  #       uses: docker/setup-qemu-action@v3

  #     - name: Enable binfmt_misc (only for emulated builds)
  #       if: matrix.platform != 'linux/amd64' && matrix.runner == 'ubuntu-latest'
  #       run: |
  #         docker run --rm --privileged multiarch/qemu-user-static --reset -p yes || echo "binfmt setup completed"

  #     - name: Log in to GitHub Container Registry
  #       uses: redhat-actions/podman-login@v1
  #       with:
  #         registry: ${{ env.REGISTRY }}
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}

  #     - name: Create or use device-specific config.toml
  #       run: |
  #         CONFIG_PATH="devices/${{ matrix.device-type }}/config.toml"
  #         if [ -f "$CONFIG_PATH" ]; then
  #           echo "Using device-specific config: $CONFIG_PATH"
  #           cp "$CONFIG_PATH" ./config.toml
  #         elif [ ! -f config.toml ]; then
  #           echo "Creating default config.toml"
  #           cat > config.toml << 'EOF'
  #         [[runner]]
  #         name = "org.osbuild.rhel90"
  #         label = "rhel-9.0-x86_64"
  #         distro = "rhel-90"
  #         EOF
  #         fi

  #     - name: Build artifacts for each format
  #       run: |
  #         set -euo pipefail
          
  #         # Use the device-specific multi-platform manifest image for artifact building
  #         IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
  #         PLATFORM="${{ matrix.platform }}"
  #         ARCH="${{ matrix.arch }}"
  #         DEVICE_TYPE="${{ matrix.device-type }}"
          
  #         echo "Building artifacts from multi-platform image: $IMAGE"
  #         echo "Target platform: $PLATFORM"
  #         echo "Target architecture: $ARCH"
  #         echo "Device type: $DEVICE_TYPE"
          
  #         # Parse formats from job output
  #         IFS=',' read -ra FORMATS <<< "${{ needs.setup.outputs.formats }}"
          
  #         # Create output directory
  #         mkdir -p ./bootc-exports/$DEVICE_TYPE/$ARCH
          
  #         for FORMAT in "${FORMATS[@]}"; do
  #           echo "Building $FORMAT for $PLATFORM (device: $DEVICE_TYPE)"
            
  #           IMAGE_NAME_TAG=$(basename "$IMAGE")
  #           SANITIZED_NAME_TAG=$(echo "$IMAGE_NAME_TAG" | sed 's/:/_/')
  #           DIR_NAME=$(echo "$SANITIZED_NAME_TAG" | sed 's/[^A-Za-z0-9._-]/_/g')
  #           DIR_NAME=${DIR_NAME}-${FORMAT}
            
  #           OUTPUT_DIR="./bootc-exports/$DEVICE_TYPE/$ARCH/$DIR_NAME"
  #           mkdir -p "$OUTPUT_DIR"
            
  #           # Pull the multi-platform image and let podman select the right arch
  #           echo "Pulling multi-platform image: $IMAGE"
  #           podman pull --platform=$PLATFORM $IMAGE
            
  #           echo "Building $FORMAT artifact for $ARCH architecture (device: $DEVICE_TYPE)"
            
  #           # Run bootc-image-builder
  #           sudo podman run \
  #             --platform=$PLATFORM \
  #             --rm \
  #             --privileged \
  #             --pull=newer \
  #             --security-opt label=type:unconfined_t \
  #             -v ./config.toml:/config.toml:z \
  #             -v "$PWD/$OUTPUT_DIR:/output" \
  #             -v /var/lib/containers/storage:/var/lib/containers/storage \
  #             registry.redhat.io/rhel9/bootc-image-builder:latest \
  #             --target-arch $ARCH \
  #             --type $FORMAT \
  #             --use-librepo=True \
  #             $IMAGE
            
  #           echo "Artifact built successfully in $OUTPUT_DIR"
  #           ls -la "$OUTPUT_DIR"
            
  #           # Upload artifact to OCI registry - use device-specific image base for diskimage repo
  #           IMAGE_BASE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
  #           OCI_DISK_IMAGE_REPO=${IMAGE_BASE}/diskimage-${FORMAT}
  #           OCI_IMAGE_TAG=${{ github.sha }}-${ARCH}
            
  #           # Create manifest
  #           sudo podman manifest create ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} || true
            
  #           # Determine artifact type and file path
  #           case "$FORMAT" in
  #             "anaconda-iso")
  #               ARTIFACT_TYPE="application/vnd.diskimage.iso"
  #               FILE_PATH="$OUTPUT_DIR/bootiso/install.iso"
  #               ;;
  #             "qcow2")
  #               ARTIFACT_TYPE="application/vnd.diskimage.qcow2"
  #               FILE_PATH="$OUTPUT_DIR/qcow2/disk.qcow2"
  #               ;;
  #             "vmdk")
  #               ARTIFACT_TYPE="application/vnd.diskimage.vmdk"
  #               FILE_PATH="$OUTPUT_DIR/vmdk/disk.vmdk"
  #               ;;
  #             "raw")
  #               ARTIFACT_TYPE="application/vnd.diskimage.raw"
  #               FILE_PATH="$OUTPUT_DIR/image/disk.raw"
  #               ;;
  #             *)
  #               echo "Unknown format: $FORMAT"
  #               continue
  #               ;;
  #           esac
            
  #           # Check if file exists
  #           if [ ! -f "$FILE_PATH" ]; then
  #             echo "Error: Expected file not found at $FILE_PATH"
  #             echo "Available files:"
  #             find "$OUTPUT_DIR" -type f
  #             continue
  #           fi
            
  #           echo "Adding artifact to manifest"
  #           sudo podman manifest add \
  #             --artifact --artifact-type $ARTIFACT_TYPE \
  #             --arch $ARCH --os=linux \
  #             ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} \
  #             "$FILE_PATH"
            
  #           echo "Pushing manifest to registry"
  #           sudo podman manifest push --all \
  #             ${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG} \
  #             docker://${OCI_DISK_IMAGE_REPO}:${OCI_IMAGE_TAG}
            
  #           echo "Successfully pushed $FORMAT artifact for $ARCH (device: $DEVICE_TYPE)"
  #         done

  #     - name: Upload build artifacts
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: bootc-artifacts-${{ matrix.device-type }}-${{ steps.platform.outputs.safe_arch }}
  #         path: ./bootc-exports/
  #         retention-days: 7

  # Summary job
  summary:
    name: Build Summary
    #needs: [detect-changes, setup, build-image, create-manifest, build-artifacts]
    needs: [detect-changes, setup, build-image, create-manifest]
    runs-on: ubuntu-latest
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    env:
      REGISTRY: ghcr.io/${{ github.repository_owner }}
    steps:
      - name: Print build summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "### Device Types Built" >> $GITHUB_STEP_SUMMARY
          echo "- Device Types: ${{ needs.setup.outputs.device-types }}" >> $GITHUB_STEP_SUMMARY
          echo "- Platforms: ${{ needs.setup.outputs.platforms }}" >> $GITHUB_STEP_SUMMARY
          #echo "- Artifact Formats: ${{ needs.setup.outputs.formats }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### Multi-platform Images" >> $GITHUB_STEP_SUMMARY
          IFS=',' read -ra DEVICE_ARRAY <<< "${{ needs.setup.outputs.device-types }}"
          for DEVICE_TYPE in "${DEVICE_ARRAY[@]}"; do
            echo "#### Device Type: $DEVICE_TYPE" >> $GITHUB_STEP_SUMMARY
            echo "- Latest: ${{ env.REGISTRY }}/device-example-${DEVICE_TYPE}:latest" >> $GITHUB_STEP_SUMMARY
            echo "- SHA: ${{ env.REGISTRY }}/device-example-${DEVICE_TYPE}:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "**Platform-specific Images:**" >> $GITHUB_STEP_SUMMARY
            IFS=',' read -ra PLATFORM_ARRAY <<< "${{ needs.setup.outputs.platforms }}"
            for PLATFORM in "${PLATFORM_ARRAY[@]}"; do
              ARCH="${PLATFORM#linux/}"
              echo "- $ARCH: ${{ env.REGISTRY }}/device-example-${DEVICE_TYPE}:${{ github.sha }}-${ARCH}" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          echo "- Change Detection: ${{ needs.detect-changes.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Setup: ${{ needs.setup.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Base Image Build: ${{ needs.build-image.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Manifest Creation: ${{ needs.create-manifest.result }}" >> $GITHUB_STEP_SUMMARY
          #echo "- Artifact Build: ${{ needs.build-artifacts.result }}" >> $GITHUB_STEP_SUMMARY

      - name: Print no changes message
        if: needs.detect-changes.outputs.has-changes == 'false'
        run: |
          echo "## No Changes Detected" >> $GITHUB_STEP_SUMMARY
          echo "No changes were detected in any device type directories. Build skipped." >> $GITHUB_STEP_SUMMARY